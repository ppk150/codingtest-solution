## DFS 

DFS는 공부해도 "다른거에 적용해봐" 혹은 "스스로 재귀함수 짜봐" 라고 하면 못하는 경우가 있다.

내가 그렇다 ....ㅎ!

아무래도 그냥 뭐 막 여러개 풀어보는 수 밖에 없는것 같다. 

이번에는 부분집합 찾기 문제다 

DFS 관련 자료는 어떤 치킨 좋아하는 놈이 써놨다. 

[https://half-forty.tistory.com/89](https://half-forty.tistory.com/89)

 [JAVA\_코딩테스트 준비\_이진트리순회 (DFS)

DFS DFS는 탐색 알고리즘으로, 코딩테스트에 빈출되는 유형이라고 한다. 사실 DFS, BFS, 부르트 포스 등등 탐색 알고리즘은 많지만, 코테로 나오면 사실상 DFS 하면 깔끔히 풀리는게 많다고 한다. (다

half-forty.tistory.com](https://half-forty.tistory.com/89)

이번에는 다른 예제를 해 보자 

### 부분 집합 문제 

자연수 N 이 주어지면 1부터 N 까지의 숫자를 원소로 갖는 집합의 부분집합을 모두 출력하는 프로그램을 만들어라

\*\*위 문제는 1~3 까지를 기준으로 풀 것이다. 

_**"그냥 1 2 3 으로 조합 가능한 경우의 수 찾으려면 부르트 포스 하면 되는거 아니냐? "**_

맞다 그런데 DFS 로 풀거임

1~3까지 숫자를 사용 하는지, 안하는지 (2지선다), 어떤 숫자가 들어가는지... 

사용하는 경우 안하는경우를 그림으로 그려보면...

[##_Image|kage@dV7QOW/btr0aRpYC5f/0gjkwE5wVHfzlKgXPHoKWK/img.png|CDM|1.3|{"originWidth":1531,"originHeight":960,"style":"alignCenter","caption":"엥 이거 완전 이진트리 아니냐?"}_##]

이렇게 이진 트리로 나타낼 수 있다. 

DFS를 풀때 기본적으로 가능하다면, 이진트리로 처리하는게 정석인것 같다.

아직 많은 문제를 풀지 못했지만, 쉬운건 죄다 이진트리로 만들고 푸는 예제만 있다. ㅠㅠ   
(추후에 복잡한 문제도 풀어봐야할듯)

위의 이진트리를 보면 숫자를 사용 하고, 안하고를 Yes, No 로 마치 경로처럼 나타낼 수 있는데

\-> 모든 경로를 탐색 = 모든 경우의 수 짜잔!

모든 경로를 탐색하면 (위의 그림의 경로를 한번 따라가 보면서 생각하면 쉽다.)

1 2 3   
1 2   
1 3   
1   
2 3   
2   
3

이캐캐 된다. (공집합 제외 )

그러면, 이제 코드로 구현하기 앞서서 조건을 설정해 주어야 한다. 

먼저, 재귀함수가 **끝나는 지점 설정**을 해준다. 

위의 예제에서는 3까지 인데, 사실상 입력받은 N이 어느정도의 수가 들어올지 알 수 없으므로, 단순히 마지막 노드에 null을 넣는 방식은 안된다. 

그런데, 이게 부분집합이 넣어지는 숫자에 따라 갯수가 다른거지, 경로가 바뀌는건 아니다. (1 2 3 / 1 2 ...를 여튼 다 지난다)

고로, 로직은 경로를 싹다 쭉쭉 탐색할 수 있는 로직을 만들고, **입력받은 N보다 많은 숫자로 넘어가면 브레끼**를 걸어주면 된다. 

그리고 **숫자의 유무에 따라 경로를 틀어주는 부분**을 만들면 끝

### **코드 예시**

```
public class DFS2 {

    static int n;
    static int[] ch; // 숫자가 사용 되는지 안되는지 표시하는 배열 -> 인덱스 = 숫자 / 내부 값 1 사용 , 0 사용 안함

    public void DFS(int L){
        if(L == n +1){ // 경로 맨 끝으로 가면 -> 해당 경로는 다 탐색 한것이니 출력만 하면 됨

            String tmp = "";
            for(int i = 0 ; i <= n; i++){

                if(ch[i] == 1 ){

                    tmp += (i + " "); // 해당 숫자를 사용할 때 -> 그 숫자를 출력하게 (경로상의 숫자 출력)

                }
            }

                if(tmp.length() > 0 ){
                    System.out.println(tmp); // 경로들 통과한 수만 출력 -> 공집합은 안나옴
                }

        }else{
            
            ch[L] = 1; // 해당 숫자 사용
            // 여기서 L은 노드의 숫자가 된다 , 즉 L 인덱스(숫자)에 1 이 드감 = L 사용됨
            DFS(L + 1 ); // 숫자를 사용 할때의 경로 (트리 그림에서 왼쪽)
            ch[L] = 0;// 해당 숫자 사용 안함
            DFS(L + 1); // 숫자를 사용 하지 않을 때의 경로 (트리 그림에서 오른쪽)

        }
    }

    public static void main(String[] args) {

        DFS2 T = new DFS2();
        n = 3 ;
        ch = new int[n + 1];// 숫자 0 은 포함 안해서 1 부터 셈, 0 1 2 3 이캐캐 됨 (배열크기 4)
        T.DFS(1);
    }
}
```

이번에는 static으로 -클래스 내에서 사용하는 변수를 만들어 줫다. 

이때 ch 배열을 잘 봐야 하는데, 이 배열이 우리가 탐색해야 하는 숫자들에 관한 배열이라고 생각하면 된다.

다만, 배열 안의 값이 아니고 배열의 인덱스(배열 값에 해당하는 "자리" )가 우리가 경로로 지나는 숫자인 것이다. 

이 자리에 1이 들어가면 해당 숫자가 포함되는 것이고, 0이면 포함되지 않는 것이다. 

맨 아래쪽에 보면 n에 3을 넣어놧는데, 이렇게 되면 ch = new int\[n+ 1\] 으로 크기가 4 인 배열이 생성된다. 

그래서, 위쪽에 재귀가 동작 할 때 맨 끝 부분 (n+1가 되는 부분, 인덱스 상으로는 3 이 된다.)에 다다르면 해당 재귀를 끝내면서 경로를 출력하는 것이다. 

이때 이 부분을 잘 봐야 한다. 

```
ch[L] = 1;
DFS(L + 1 ); 
ch[L] = 0;
DFS(L + 1); 
```

단순하지만, L+1 으로 1씩 증가하면서 재귀가 실행되는데, L +1 = n +1 인 상황에서 재귀가 끝나게 된다. 

그러면 바로 밑의 ch\[L\] = 0 이 실행되게 되고, 이때부터는 해당 숫자가 포함되지 않은 경로를 탐색한다는 것이다.

그림으로 보면 쉽다. 

먼저 1 - 2 - 3  순으로 경로를 탐색 했다면 

[##_Image|kage@cJ7npJ/btr0glQNjk5/qQKtkIFvjGka5IWplzSGM0/img.png|CDM|1.3|{"originWidth":957,"originHeight":570,"style":"alignCenter","caption":"1 - 2 - 3 순 탐색"}_##]

스텍 메모리에 1 - 2 - 3 순으로 차곡차곡 쌓인다.

[##_Image|kage@kDIW5/btr0gCrn9QW/Ewl9NZsL9L0yxr8lpUCGck/img.png|CDM|1.3|{"originWidth":199,"originHeight":149,"style":"alignCenter","caption":"1 - 2 - 3 스텍 메모리"}_##]

그런데, 3Y (3을 사용하는 경로) 로 가면 n + 1인 상황이므로 재귀가 끝나고, 출력 후 아래의 코드가 실행되게 된다. 

```
ch[L] = 0;
DFS(L + 1);
```

이때, L 에 해당하는 자리의 값은 0 이되는데, L은 현 시점 3 이다. 

3이 사용되지 않는 값(0)으로 지정되고, 바로 다음 DFS(L + 1) 을 실행하면 L + 1 = n + 1 인 상태가 된다. 

이 코드가 실행될 때의 경로는 

[##_Image|kage@df7vsb/btr0h2Dcv4o/LesiQogtePmXs5okXh4ciK/img.png|CDM|1.3|{"originWidth":915,"originHeight":564,"style":"alignCenter","caption":"3을 제외하고 1 - 2 를 지나게 된다."}_##]

그러면 이 때의 스텍 메모리는 

[##_Image|kage@lGXPf/btr0e8kollY/W5yv7ID0jHXvk90wDnkPsk/img.png|CDM|1.3|{"originWidth":199,"originHeight":137,"style":"alignCenter","caption":"1 - 2 를 지나고, 3은 안지남"}_##]

이캐캐 된다. 

이때, L + 1 = n + 1 인 상태이니 다시 출력 하게 되는데, 3을 제외한 1 2 가 출력되는 것이다. 

이 후 재귀 함수 동작에 따라 스텍 메모리가 바뀌면서 탐색을 해나간다 

**PS : _"~~~이를 반복해서 DFS 완성!"_ 이라고 하고 싶은데** 

**이게 글로 써서 알려주니까 조금 더 설명이 있으면 좋으련만**

**모든 동작을 그림으로 해주기에는 문제가 있다.** 

**일단 나 자신도 좀 헷갈리는 부분도 있고  
(코드 보고 그림 그리고 코드 보고 그림 그리고.... 이 글 쓰는데 적어도 2~3시간 걸렸다.)**

**아무래도 이건 직접 손으로 그려보면서 하면 동작방식은 이해가 쉬울거다.** 

**문제는 "재귀 함수 코드" 가 실시간으로 불어나면서 "이때 어디 경로로 가겠군!" 하는 것을 바로바로 알기 어렵다...** 

**머릿속에서 정리가 안된다.** 

**스텍 메모리에 이렇게 들어가고... 이렇게 동작한다 이거는 알겠는데** 

**사실상 코드 상에서는 이런식으로 동작 할텐데** 

```
DFS(DFS(DFS(DFS(L + 1 )L + 1 )L + 1 )L + 1 )
```

**이게 머리속에서 촤자자작 하고 생각이 안된다....** 

**많이 풀어서 익숙해지는거말고 답이 없어보인다.... 아니면 재귀없이 stack 으로 푸는걸 연습하거나(이건 너무 비효율적인디 ㅠㅠ)**

**여튼... 오늘도 일단 한문제 풀고, 공부 했다.** 

**다음에는 이진트리가 아닌DFS를 찾아서 해봐야 겠다.**
